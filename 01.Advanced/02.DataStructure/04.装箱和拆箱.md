# 装箱 和 拆箱

**1. 装箱在值类型向引用类型转换时发生**

```C#
object obj = 1;
```

这行语句将整型常量 1 赋给 object 类型的变量 obj.

常量 1 是 **值类型**，值类型是要放在 **stack （栈）** 上的，而 **object** 是 **引用类型**，它需要 放在 **heap（堆）** 上.

要把值类型放在堆上就需要执行一次装箱操作.

- 以上就是装箱所要执行的操作了，执行装箱操作时，不可避免的要在 **heap(堆）** 上申请内存空间，并将堆栈上的值类型数据复制到申请的内存空间上，这肯定是要消耗内存和CPU资源的.

**2. 拆箱在引用类型向值类型转换时发生**

```C#
object obj = 4;
int value = (int)obj;
```

上面的两行代码会执行一次装箱操作将整形数字常量 4 装箱成引用类型 object 变量 obj.

然后又执行一次拆箱操作，将存储到堆上的引用变量 obj 存储到局部整形值类型变量 value 中.

拆箱操作的执行过程和装箱操作过程正好相反，是将存储在堆上的引用类型值转换为值类型并给值类型变量.

转向操作和拆箱操作是要额外耗费 **CPU** 和 **内存资源** 的，所有在 C# 2.0 之后引入了 **泛型** 来减少装箱操作和 拆箱操作的消耗.

```C#
using System;
using System.Collections;

namespace Test1
{
    class Test
    {
        static void Main(string[] args)
        {
            ArrayList arr = new ArrayList();

            arr.Add(1);             //  装箱

            int n = (int)arr[0];    //  拆箱
        }
    }
}
```