# 多态

**多态是同一个行为具有多个不同表现形式或形态的能力,意味着有多重形式。**

在面向对象编程范式中，多态性往往表现为"一个接口，多个功能"。

多态性可以是静态的或动态的。在静态多态性中，函数的响应是在编译时发生的。在动态多态性中，函数的响应是在运行时发生的。

## Advantage

提高了代码的灵活性

## 动态多态性（运行时多态）

它是 C# 运行时的特性。

即在编译用户的程序代码时不将对某一方法的调用与对应的具体方法互相联系起来，而是在执行过程中依据对象的实际类型相应地生成对该对象所在类中的方法最终调用的程序代码。

由于调用方法的引用可能指向父类或子类的对象（上转型对象），因此可以根据 **"是谁的对象就调用谁的方法"** 的原则确定调用同名方法中的哪一个，因此在父、子类中定义同名、甚至参数列表相同的方法是允许的。

当然，确定调用方法的引用指向父类还是子类的对象在编译时无法完成，只能在运行时确定。


## 静态多态性（编译时多态）

它是 C# 编译时特性。

即在编译用户的程序代码时，就将某一方法的调用与对应的具体方法相互联系起来，生成最终的程序代码。

同名方法由于参数列表不同，在编译时就可以根据调用方法的形式确定到底执行哪个方法的代码，因此这种方法的同名时允许的。

```C#
using System;

namespace Lesson01
{

    class Animal
    {
        private string name;
        private string color;

        // 编译时多态 - 构造函数 & 重载
        // 无参构造 和 有参构造 属于 编译时多态
        public Animal()
        {
            // empty
        }

        public Animal(string name, string color)
        {
            this.name = name;
            this.color = color;
        }

        // 重载 也属于 编译时多态
        public void eat()
        {
            Console.WriteLine("Eat it without parameter.");
        }

        public void eat(int i)
        {
            Console.WriteLine("Eat it with parameter.");
        }

        // 运行时多态 - override & hide
        // override
        public virtual void call()
        {
            Console.WriteLine("Animal call.");
        }

        // hide
        public void legs()
        {
            Console.WriteLine("Animal with legs.");
        }
    }

    class Dog : Animal
    {
        string yell;
        int number;

        public Dog()
        {
            // empty
        }

        public Dog(string name, string color, string yell, int number) : base(name, color)
        {
            this.yell = yell;
            this.number = number;
        }


        // 运行时多态 - override & hide
        // override
        public override void call()
        {
            Console.WriteLine("Dog yell : " + this.yell);
        }

        // hide
        public new void legs()
        {
            Console.WriteLine("Dog have {0} legs." + this.number);
        }
    }

    class FirstClass
    {
        static void Main(string[] args)
        {
            Animal a = new Animal();
            a.eat();
            a.eat(10);

            Console.WriteLine();

            Dog d = new Dog("Dog", "Black", "Wang~Wang~", 4);
            d.call();
            d.legs();
        }
    }
}
```
```
output

Eat it without parameter.
Eat it with parameter.

Dog yell : Wang~Wang~
Dog have 4 legs.
```
