# 覆盖、重载、隐藏

## 覆盖 override(过载、重写)

指子类对父类中虚函数或抽象函数的“覆盖”（这也就是有些书将过载翻译为覆盖的原因），但是这种“覆盖”和用new关键字来覆盖（隐藏）是有区别的。

- 同名方法构成覆盖的条件
  - 方法分别在父、子类中定义
  - 父类中的方法用 **virtual** 修饰
  - 子类中的方法用 **override** 修饰
  - 同名同参返回值类型

- override重写特性：

    - 由 override 声明重写的方法称为重写基方法，重写的基方法必须与 override 方法具有相同的签名。

    - 覆盖的基方法必须是 virtual、abstract 或 override 的，不能重写非虚方法或静态方法。
  
    - override的方法和virtual的方法必须具有相同的访问级别修饰符，不能更改 virtual 方法的可访问性。
  
    - 不能使用new、static 或 virtual 修饰符来修改 override 方法。
  
    - 重写属性声明必须指定与继承属性完全相同的访问修饰符、类型和名称，并且被重写的属性必须是virtual、abstract 或 override 的。

## 重载（overload)

- 同名方法构成重载的条件
  
  - 参数列表不同（包括参数的个数、类型、不同类型参数的顺序），方法的返回值不能构成重载的条件。

## 隐藏（new 覆盖)

new 覆盖指的是不同类中（基类或派生类）有两个或多个返回类型、方法名、参数都相同，但是方法体不同的方法。

但是这种覆盖是一种表面上的覆盖，所以也叫 **隐藏**。

- 在 Upcasting 中，**被隐藏的父类方法是可以调用得到的**。

  
## 覆盖 override 、 重载 overload、隐藏(new) 的区别

- override 
  
  - 必然发生在基类和派生类中,其类函数用virtual修饰,派生类用override修饰.
  
  - **在 Upcasting 中 已被 派生类 方法覆盖**.

- overload 
  
  - 必然发生在一个类中,函数名相同,参数类型或者顺序不同构成重载,与返回类型无关

- new 
  
  - 在子类中，写一个和基类一样名字(参数不同也算)的非虚函数,会让基类中的函数被隐藏,编译后会提示要求使用New关键字
  
  -  **在 Upcasting 中 只是被隐藏，仍可以被调用**.

## 覆盖（override & new override) 与 重载 （overload）的区别

- 从方法声明角度 ：
  - 重载的两个函数参数列表不同；
  - 覆盖的两个方法参数列表和返回值相同.

- 从所处的位置角度：
  - 重载的两个方法在同一类中；
  - 覆盖的两个方法在有继承关系的两个类中.

- 从方法调用角度：
  - 重载的方法被同一对象使用不同的参数调用；
  - 覆盖的方法被不同对象使用相同参数调用.
  
- 从多态时机角度：
  - 重载的方法在编译时多态；
  - 覆盖的方法在运行时多态.

```C#
using System;

namespace Lesson01
{
    class A
    {
        // override
        // virtual method
        public virtual void print()
        {
            Console.WriteLine("Override - This is A class.");
        }

        // overload
        public void add(int a, int b)
        {
            Console.WriteLine("\nOverloda add method with 2 parameters.");

            int sum = a + b;
            Console.WriteLine(a + " + " + b + " = " + sum);
        }

        public void add(int a, int b, int c)
        {
            Console.WriteLine("\nOverloda add method with 3 parameters.");

            int sum = a + b + c;
            Console.WriteLine(a + " + " + b + c + " = " + sum);
        }

        // new hide
        public void hide()
        {
            Console.WriteLine("\nThis is A class hide method.");
        }
    }

    class B : A
    {
        // override - 重载
        public override void print()
        {
            Console.WriteLine("Override - This is B class.");
        }

        // new hide
        public new void hide()
        {
            Console.WriteLine("\nThis is B class hide method.");
        }
    }

    class FirstClass
    {
        static void Main(string[] args)
        {
            A a = new A();
            a.print();

            a.add(1, 2);
            a.add(1, 2, 3);

            Console.WriteLine();

            B b = new B();
            b.print();

            Console.WriteLine();

            A c = new B();
            c.hide();       // 在 Upcasting 中 new override - hide 的 base class 方法是能够被调用的
            c.print();      // 在 Upcasting 中 override 的 base class 方法是不能能够被调用的，已被 派生类 覆盖

        }
    }
}
```

```
output:
Override - This is A class.

Overloda add method with 2 parameters.
1 + 2 = 3

Overloda add method with 3 parameters.
1 + 23 = 6

Override - This is B class.


This is A class hide method.
Override - This is B class.
```