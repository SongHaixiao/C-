# 静态成员

1. 通过 static 关键字修饰，是属于类，实例成员属于对象，在这个类第一次加载的时候，这个类下面的所有静态成员会被加载.

2. 静态成员只被创建一次，所以静态成员只有一份，实例成员有多少个对象，就有多少份.

3. 类加载的时候，所有的静态成员就会被创建 **静态存储区** 里面，一旦创建直到程序退出,才会被回收.

4. 成员需要被共享的时候，方法需要被反复调用的时候，就可以把这些成员定义为静态成员.

5. 在静态方法中，不能直接调用实例化成员，因为静态方法被调用的时候，对象还有可能不存在.

6. **this/base** 关键字在静态方法不能使用，因为有可能对象不存在.

7. 可以创建这个类的对象，制定对象的成员在静态方法中操作.

8. 在实例方法中，可以调用静态成员，因为这个时候静态成员肯定存在.

9. 非静态类可以包含静态的方法、字段、属性或事件.

10. 无论对一个类创建多个实例， 它的静态成员都只有一个副本.

11. 静态方法和属性不能访问其包含类型中的非静态字段和事件，并且不能访问任何对象的对象的实例化成员.

12. 静态方法只能被重载，而不能被覆盖，因为静态方法不属于类的实例成员.
    
13. 虽然字段不能声明为 **static const**, 但是 **const** 字段的行为在本质上是静态的. 这样的字段属于类，不属于类的实例.s

## 静态变量

实例成员变量（非静态） 和 类变量（静态）

- 存储结构的差别：
  - 实例变量每次创建对象时，才被分配空间
  - 类变量当类被加载时就分配空间
  
- 访问方式的差别：
  - 实例变量必须通过对象访问
  - 类变量不需要通过对象访问，直接使用 类名.访问

## 静态方法

1. 静态方法是不属于特定对象的方法；
   
2. 静态方法可以访问静态成员；
   
3. 静态方法不可以直接访问实例成员，可以在实例函数调用的情况下，实例成员作为参数传给静态方法；

4. 静态方法也不能直接调用实例方法，可以间接调用，首先要创建一个类的实例，然后通过这一特定对象来调用静态方法.

```C#
using System;

namespace Test1
{
    class Program
    {
        static void Main(string[] args)
        {
            // static method  属于某一个类的，需要通过类名来调用
            // 如果在同一个类中可省略类名，直接调用
            Function(); // Program.Function();

            // 非静态的方法是属于类某一个对象，需要通过 object 来调用
            Program p = new Program();
            p.Function1();
        }

        public static void Function()
        {
            Console.WriteLine("Static Function can call directly.");
        }

        public void Function1()
        {
            Console.WriteLine("noe - Static Function can call via object.");
            Function();         //  同一类，省略类名，直接调用
        }
    }
}
```