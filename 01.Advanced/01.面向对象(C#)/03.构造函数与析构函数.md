# 构造函数 与 析构函数

## 构造函数

构造方法是一类特殊的成员方法，用于创建类的实例并初始化对象.

### 声明构造方法

构造方法与类同名，且没有返回值类型

注意 ：

- 系统为每个类提供一个默认的无参的构造方法，但当自行声明了构造方法后，这个默认的无参构造方法不在提供。

- 构造方法无法返回值，有返回值（即使是 void) 的成员方法不是构造方法。

- 构造方法可以重载。

### 初始化的缺省初值都是确定的：

- 布尔变量          初值 ：     false
  
- 整数变量          初值 ：     0

- 浮点数变量        初值 ：     0.0

- 字符变量          初值 ：     'a'

- 引用（复合）变量   初值 ：    null

注意 : **成员方法中的局部变量必须显式手动进行初始化**.

```C#
using System;

namespace Test
{
    public class Class1
    {
        static void Main(string[] args)
        {
            Student stu = new Student();
            stu.setScore(100);
            Console.WriteLine("get this student's score is " + stu.getScore());
        }
    }

    class Student
    {
        string name;
        int age;
        int score;

        // Constructure withou parameters
        public Student()
        {
            Console.WriteLine("Call non parameters constructure");
        }

        // Constructure with parameters
        public Student(string name, int age, int score)
        {
            this.name = name;
            this.age = age;
            this.score = score;
        }
        public void setScore(int score)
        {
            this.score = score;
        }
        public int getScore()
        {
            return score;
        }

    }
}
```

```
output:

Call non parameters constructure
get this student's score is 100
```

## 析构函数

- 析构函数用于释放被占用的系统资源

- 析构函数的名字由符号 "~" 加类名组成

- 注意 ：

  - 不能在结构中定义析构函数，只能对类使用析构函数
  
  - 一个类只能有一个析构函数
  
  - 无法继承或重载析构函数
  
  - 无法调用析构函数，析构函数自动被调用
  
  - 析构函数既没有修饰符，也没有参数

### 调用析构函数

1. 垃圾回收器决定了析构函数的调用，我们无法控制任何调用析构函数。垃圾回收器检查是否存在引用程序不再使对象。如果垃圾回收器认为某个对象符合析构，则调用析构函数（如果有）并回收用来存储此对象的内存。
   
2. 程序退出时会调用析构函数。
   
3. 可以通过调用 Collect 强制进行垃圾回收，但是请不要这样做，因为这样做可能导致性能问题。

4.  使用析构函数释放资源。通常，与运行时不进行垃圾回收的开发语言相比，C# 无需太多的内存管理。这是因为 .NETFramework 垃圾回收器会隐式地管理对象的内存分配和释放。 但是当应用程序封装窗口、文件和网络连接这类非托管资源时，应当使用析构函数释放这些资源。当对象符合析构时，垃圾回收器将运行对象的 Finalize 方法。

### 原理

- 析构函数隐式地对对象的基类调用 Finalize

- 一个类只有一个 Finalize 方法，不能重载，没有返回值
  
```C#
protected override void Finalize()
{
    try
    {
        // Cleanup Statements
    }
    finally
    {
        base.Finalize();
    }
}

```

```C#

class A
{
    ~A()
    {
        Console.WriteLine("A's destructor");
    }
}

// 在C#中，析构函数会被编译器扩展成为重写的 System.Object 的Finalize 方法，
// Finalize方法相当于析构函数的别名，只不过不允许在代码中直接出现Finalize方法的定义或对其的调用。

class A
    {
        protected override void Finalize()    // error ！
        {
            Console.WriteLine("A's destructor");
        }
    }
```

- 对继承链中的所有实例递归调用 析构函数 （Finalize 方法） --- 从派生程度最大的到派生程度最小的。下面的例子程序，执行析构函数的顺序为 3 --> 2 --> 1
  
```C#
using System;

namespace Test1
{
    class Program
    {
        static void Main(string[] args)
        {
            Third t = new Third();           
        }

        class First
        {
            ~First()
            {
                int count = 1;
                Console.WriteLine(count + "'s destructor is called.");
            }
        }

        class Second : First
        {
            ~Second()
            {
                int count = 2;
                Console.WriteLine(count + "'s destructor is called.");
            }
        }

        class Third : Second
        {
            ~Third()
            {
                int count = 3;
                Console.WriteLine(count + "'s destructor is called.");
            }
        }
    }
}

```

### 构造函数与析构函数的区别

- 构造函数和析构函数是在类中说明的两种特殊的成员函数。

- 构造函数是在创建对象时，使用给定的值将对象初始化。

- 析构函数用于释放一个对象，在对象释放前，使用析构函数做一些清理工作，它与构造函数的功能正好相反。

- 对继承链中的所有实例递归调用 构造函数 与 析构函数，顺序相反 ：
  
  - 构造函数 ---  从派生程度最小的到派生程度最大的。
  
  - 析构函数 ---  从派生程度最大的到派生程度最小的。
  

