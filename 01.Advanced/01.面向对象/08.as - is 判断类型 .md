# as - is　判断类型

### as 判断类型

1. 检查对象类型的兼容性，并返回转换结果，如果不兼容则返回 null，不会抛出异常；
2. 如果结果判断为 null，强制执行类型转换后将抛出 NullReferenceException 异常;
3. 用 as 来进行类型转换的时候，所要转换的对象类型必须是目标类型或转换目标类型的派生类.

- as 的 2 点限制：
  
  1. 类型不兼容的情况（编译器自动阻挡）；
   
  2. 转换的目标类型不能为 null 的 情况（编译器自动阻挡）. 

```C#
object o = "abc";  
string s = o as string; //执行第一次类型兼容性检查，并返回结果  
if (s != null)   
    Console.WriteLine("转换成功！");  
else  
    Console.WriteLine("转换失败！");  
```

### is　判断类型

- 检查一个对象是否兼容于其他的类型，并返回一个 Bool 值，如果一个对象是某个类型或是其父类型的话就返回 true, 否则的话就会返回为 false，永远不会抛出异常.

- 如果对象引用为 null, 那么 is 操作符总是返回为 false, 因为没有对象可以检查其类型.

```C#
object o = "abc";  
if (o is string) //执行第一次类型兼容性检查  
{  
   string s = (string)o; //执行第二次类型兼容性检查，并转换  
   Console.WriteLine("转换成功！");  
}  
else  
{  
    Console.WriteLine("转换失败！");  
}  
```

### as 与 is 的区别

1. as 在转换的同时兼具 判断兼容性，如果无法进行转换，则 as 返回 null（没有产生新的对象）而不是引发异常。有了 as 就不用 try-catch 来做类型转换的判断了，因此 as 转换成功要判断是否 为 null.

2. as 是引用类型的转换或者装箱转换，不能用于值类型的转换，如果是值类型只能结合 is 来强制转换.

3. is 只是做兼容性判断，并不执行真正的类型转换，返回 true 或 false, 不会 返回 null, 对象为 null 也会返回 false.
   
4. as 模式的效率要比 is 模式的高，因为借助 is 进行类型转换的话，需要进行执行两次类型的兼容检查，而 as 只需要做一次类型兼容，即一次 null 检查，null 检查要比类型兼容检查快.

```C#

using System;

namespace Lesson01
{
    

   // base 类
   // 虽然没有明确地继承某个类
   // 但是 其隐性地默认地继承了 object 类，object 是所有类中的基类
   class Shape
    {
        private string name;
        private int width;
        private int height;
        private string color;

        public Shape(string name, int width, int height, string color)
        {
            this.name = name;
            this.width = width;
            this.height = height;
            this.color = color;
        }

        public void setName(string name) { this.name = name; }

        public string getName() { return this.name; }

        public void setWidth(int width) { this.width = width; }

        public int getWidth() { return this.width; }

        public void setHeight(int height) { this.height = height; }

        public int getHeight() { return this.height; }

        public void setColor(string color) { this.color = color; }

        public string getColor() { return this.color; }

        // 父类 Print() 函数 设置为 virtual 将被子类 添加 override 重写
        public virtual void Print()
        {
            Console.WriteLine("Shape Name : " + this.name + "\tWidht : " + this.width + "\tHeight : " + this.height);
        }

        // 父类 printHello() 函数 将被子类 添加 new 重写
        public void PrintHello()
        {
            Console.WriteLine("Hello " + this.name);
        }

        public void DisplayColor()
        {
            Console.WriteLine("Color is " + this.color);
        }
    }

   // Rectangle 派生类
   class Rectangle : Shape
   {
        private int number;

        public Rectangle(string name, int width, int height, string color, int number) : base(name, width, height, color)
        {
            this.number = number;
        }

        public Rectangle(string name, int width, int height, string color) : base(name, width, height, color)
        {
            // empty
        }

        public int getArea()
        {
            return (getWidth() * getHeight());
        }

        // override - 子类重写 父类 Print()函数
        // 发生在父类和子类之间,父类 为 virtual 
        // 方法名称，参数，返回值一样
        public override void Print()
        {
            Console.WriteLine("派生类 Rectangle, 调用 父类 Print（）");
            base.Print();   // 调用 父类 Print()
            Console.WriteLine("Area : " + getArea() + "\tNumber : " + this.number);
        }

        // new - 子类重写 printHello() 函数
        public new void PrintHello()
        {
            Console.WriteLine("Hello {0} Class.", getName());
        }
   }

    // triangle 派生类
    class Trianle : Shape
    {
        private int number;

        public Trianle(string name, int width, int height, string color , int number) : base(name, width, height, color)
        {
            this.number = number;
        }

        public Trianle(string name, int width, int height, string color) : base(name, width, height, color)
        {
            // empty
        }

        public double getArea()
        {
            return (0.5 * getWidth() * getHeight());
        }

        // override - 子类重写 父类 Print()函数
        // 发生在父类和子类之间,父类 为 virtual 
        // 方法名称，参数，返回值一样
        public override void Print()
        {
            Console.WriteLine("派生类 Triangle, 调用 父类 Print（）");
            base.Print();   // 调用 父类 Print()
            Console.WriteLine("Area : " + getArea() + "\tNumber : " + this.number);
        }

        // new - 子类重写 printHello() 函数
        public new void PrintHello()
        {
            Console.WriteLine("Hello {0} Class.", getName());
        }
    }

    class FirstClass
    {
        static void Main(string[] args)
        {
            // Upcasting - 隐式转换 
            Shape s1 = new Trianle("T1", 300, 40, "sky-blue");
            //Shape s1 = (Trianle)new Shape("T1", 300, 40, "sky-blue"); // 强制转换
            s1.Print();

            Console.WriteLine();

            // as 转换判断
            Trianle r1 = s1 as Trianle; 
            
            if(r1 != null)
            {
                Console.WriteLine("s1 is sucess to change from Shape class to Trianle class");
            }

            else
            {
                Console.WriteLine("s1 is failed to change from Shape class to Trianle class");
            }

            Console.WriteLine();

            // is 判断类型
            if (s1 is Trianle)
            {
                Console.WriteLine("s1 is Trianle");
            }

            if(s1 is Rectangle)
            {
                Console.WriteLine("s1 is Rectangle");
            }
        }
    }
}
```

```
output:

派生类 Triangle, 调用 父类 Print（）
Shape Name : T1 Widht : 300     Height : 40
Area : 6000     Number : 0

s1 is sucess to change from Shape class to Trianle class

s1 is Trianle
```
