# 接口 (Interface)

在构建问题的类过程中，经常会遇到一种特殊的情况 ： 在描述某个类的各个方法时，对每个方法只能给出其功能实现的要求（原型声明）但不能给出具体的功能实现（函数定义体），因为所处理的问题只是一个泛泛的功能说明，并没有针对某一具体类型的问题来说明.

## 定义

要点 ：类似于类的定义格式，只是以 interface 作为 **定义符**.

```C#
// Format
[访问修饰符] interface 接口名
{
    返回值类型 方法名([parameters list])；  // 只声明而无方法体
}
```

接口中声明的方法都是 默认为 public的，可以省略不写，但是不能自定义其他的访问级别.

### 含义

一组只有成员方法声明没有方法体的方法集.

接口定义了一组成员函数，但没有具体加以实现，其实现则是由实现该接口的类来加以具体完成的.

接口中只能包含方法、属性、索引器和事件的声明.

### 作用

- 提供了完全的抽象;

- 说明所有实现该接口的类应具有的形式;

- 接口中的方法在多个实现接口的类中表现出多态性. 

### 注意 

- 接口中的成员方法声明均为 public，可以省略不写

- 继承自接口的类必须 全部 实现 接口中的方法，否则报错

## 实现接口

- 通过定义一个类同时采用 ： 来指明所实现的接口名，并在该类中重写接口中的所有成员方法且给出方法体定义.

- 类中所实现的接口中的成员函数的原型都应该与在接口中的原型定义保持一致，并在类中重写接口中的所有成员方法，通过实现接口，从而可以扩充或增加该类的功能.

- 接口只定义方法名，而类实现接口内部的方法的代码.

- 接口是多继承的，类是单继承的，即一个类可以实现多个接口.

### 接口的实现分为 ：隐式实现和显式实现。

- 如果 类 或者 结构要实现的是 单个接口，可以使用 **隐式实现**；如果 类 或者结构实现了多个接口，那么接口中 **相同名称成员就要显式实现**。

- 显式实现是通过使用接口的完全限定名（接口名.方法名）来实现接口成员的.

```C#
// 语法
class_name : interface_list(用 , 分割)
{
    // 所有接口定义方法的实现
}
```
## Example

```C#
// 单接口
using System;

namespace Test
{
    class InterfaceTest
    {
        static void Main(string[] args)
        {
            Dog d = new Dog();

            d.Drink();
            d.Eat();
            d.Sleep();
            d.Yell();
        }
        
    }

    public interface Animal_1
    {
        // 接口中的成员方法声明均为 public，可以省略不写
        void Eat();
        void Drink();
    }

    public interface Animal_2
    {
        void Sleep();
        void Yell();
    }

    public class Dog : Animal_1, Animal_2
    {
        // 接口是多继承的，类是单继承的
        // 继承自接口的类必须 全部 实现 接口中的方法，否则报错
        public void Eat()
        {
            Console.WriteLine("Dog eats...");
        }

        public void Drink()
        {
            Console.WriteLine("Dog drinks...");
        }

        public void Sleep()
        {
            Console.WriteLine("Dog Sleeps...");
        }

        public void Yell()
        {
            Console.WriteLine("Dog yells...");
        }
        
    }
}

```

```
output:

Dog drinks...
Dog eats...
Dog Sleeps...
Dog yells...
```

```C#
// 多接口
using System;

namespace Test
{
    class InterfaceTest
    {
        static void Main(string[] args)
        {
            // 继承多接口，非重名方法，隐式实现
            // 实例化时 前面类型可以是 继承接口的 类名
            Dog d = new Dog();

            d.Drink();
            d.Eat();
            d.Sleep();
            d.Yell();

            // 继承多接口，重名方法，显式实现
            // 实例化时，前面类型必须是 接口名
            I_Animal_1 a = new Dog();
            a.Walk();

            I_Animal_2 d1 = new Dog();
            d1.Walk();

        }
        
    }

    public interface I_Animal_1
    {
        // 接口中的成员方法声明均为 public，可以省略不写
        void Eat();
        void Drink();

        void Walk();
    }

    public interface I_Animal_2
    {
        void Sleep();
        void Yell();
        void Walk();
    }

    public class Dog : I_Animal_1,I_Animal_2
    {
        // 接口是多继承的，类是单继承的
        // 继承自接口的类必须 全部 实现 接口中的方法，否则报错

        // 继承多接口，非重名方法，隐式实现
        public void Eat()
        {
            Console.WriteLine("Dog eats...");
        }

        public void Drink()
        {
            Console.WriteLine("Dog drinks...");
        }

        public void Sleep()
        {
            Console.WriteLine("Dog Sleeps...");
        }

        public void Yell()
        {
            Console.WriteLine("Dog yells...");
        }

        // 继承多接口，重名方法，显式实现
        void I_Animal_1.Walk()
        {
            Console.WriteLine("Dog walks_1...");
        }
        void I_Animal_2.Walk()
        {
            Console.WriteLine("Dog walks_2...");
        }
    }
}
```

```
Dog drinks...
Dog eats...
Dog Sleeps...
Dog yells...
Dog walks_1...
Dog walks_2...
```
